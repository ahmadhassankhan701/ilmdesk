import { View, Text, Image, Link, Svg, Circle } from "@react-pdf/renderer";

function wrapImagesInContainer(html) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(html, "text/html");

  const images = doc.querySelectorAll("img");

  images.forEach((img) => {
    // Create the wrapper div
    const wrapper = document.createElement("div");
    wrapper.style.width = "100%";
    wrapper.style.display = "flex";
    wrapper.style.justifyContent = "center";
    wrapper.style.alignItems = "center";

    // Style the image
    img.style.maxWidth = "100%";
    img.style.maxHeight = "100%";
    img.style.objectFit = "contain";

    // Replace the image with the wrapper
    img.parentNode.insertBefore(wrapper, img);
    wrapper.appendChild(img);
  });

  return doc.body.innerHTML;
}

/**
 * Recursive rendering function for transformed data.
 * This function takes the JavaScript object representation generated by replaceHtmlTags
 * and converts it into actual React PDF Renderer components (JSX).
 *
 * @param {Array<object>} data An array of JavaScript objects representing the transformed HTML elements.
 * @returns {Array<React.ReactElement>} An array of React PDF Renderer components.
 */
const renderPdfContent = (data) => {
  if (!Array.isArray(data)) {
    console.error("renderPdfContent received non-array data:", data);
    return null;
  }

  return data.map((item, index) => {
    if (typeof item !== "object" || item === null || !item.type) {
      console.warn("Invalid item in transformed data:", item);
      if (typeof item === "string" || typeof item === "number") {
        return <Text key={index}>{item}</Text>;
      }
      return null;
    }

    let Component;
    switch (item.type) {
      case "View":
        Component = View;
        break;
      case "Text":
        if (item.props && item.props.src) {
          Component = Link; // Use Link component for <a> tags
        } else {
          Component = Text;
        }
        break;
      case "Image":
        Component = Image;
        break;
      case "Svg": // If you ever pass Svg objects directly
        Component = Svg;
        break;
      case "Circle": // If you ever pass Circle objects directly
        Component = Circle;
        break;
      default:
        console.warn(`Unknown component type: ${item.type}`);
        return null;
    }

    const childrenToRender =
      item.children && item.children.length > 0
        ? renderPdfContent(item.children) // Recursively render children
        : null;

    return (
      <Component key={index} {...item.props}>
        {childrenToRender}
      </Component>
    );
  });
};

/**
 * Recursively converts a DOM node into an array of JavaScript objects
 * suitable for rendering with React PDF Renderer components.
 *
 * @param {Node} node The DOM node to convert.
 * @param {object} [parentStyle={}] The inherited style from the parent node.
 * @param {object} [listItemCounter={ value: 1 }] Counter for ordered list items, passed by reference.
 * @returns {Array<object>} An array of objects representing the converted nodes.
 */
function convertNodeToReactPdfObject(
  node,
  parentStyle = {},
  listItemCounter = { value: 1 }
) {
  const results = [];

  // --- Text Nodes ---
  if (node.nodeType === Node.TEXT_NODE) {
    const textContent = node.textContent;
    if (
      textContent.trim() === "" &&
      node.parentNode &&
      node.parentNode.childNodes.length > 1
    ) {
      return []; // Ignore ignorable whitespace text nodes
    }
    results.push({
      type: "Text",
      props: { style: { ...parentStyle } },
      children: [textContent], // Text children are always strings
    });
    return results;
  }

  // --- Element Nodes ---
  if (node.nodeType === Node.ELEMENT_NODE) {
    let type;
    const props = {};
    let currentStyle = { ...parentStyle }; // Inherit parent styles
    const childrenOfCurrentNode = []; // Temporarily store children processed for this node

    // --- Parse inline styles from HTML 'style' attribute ---
    if (node.hasAttribute("style")) {
      const styleAttr = node.getAttribute("style");
      styleAttr.split(";").forEach((s) => {
        const [key, value] = s.split(":").map((part) => part.trim());
        if (key && value) {
          const camelKey = key.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
          let parsedValue = value;

          if (key.includes("font-size") && value.endsWith("px")) {
            parsedValue = parseFloat(value) * 0.75; // Rough px to pt conversion (1px = 0.75pt)
          } else if (value.endsWith("px")) {
            parsedValue = parseFloat(value);
          } else if (key === "text-align") {
            currentStyle.textAlign = value;
          } else if (key === "line-height") {
            currentStyle.lineHeight = parseFloat(value);
          }
          currentStyle[camelKey] = parsedValue;
        }
      });
    }

    // --- Determine Component Type and apply specific styles ---
    switch (node.tagName.toLowerCase()) {
      case "div":
      case "section":
      case "article":
      case "header":
      case "footer":
      case "main":
      case "nav":
      case "aside":
        type = "View";
        break;
      case "p":
        type = "Text";
        currentStyle = { ...currentStyle, marginBottom: 8 };
        break;
      case "h1":
      case "h2":
      case "h3":
      case "h4":
      case "h5":
      case "h6":
        type = "Text";
        if (node.tagName.toLowerCase() === "h1")
          currentStyle = {
            ...currentStyle,
            fontSize: 24,
            fontWeight: "bold",
            marginBottom: 10,
          };
        if (node.tagName.toLowerCase() === "h2")
          currentStyle = {
            ...currentStyle,
            fontSize: 20,
            fontWeight: "bold",
            marginBottom: 8,
          };
        if (node.tagName.toLowerCase() === "h3")
          currentStyle = {
            ...currentStyle,
            fontSize: 18,
            fontWeight: "bold",
            marginBottom: 6,
          };
        if (node.tagName.toLowerCase() === "h4")
          currentStyle = {
            ...currentStyle,
            fontSize: 16,
            fontWeight: "bold",
            marginBottom: 5,
          };
        if (node.tagName.toLowerCase() === "h5")
          currentStyle = {
            ...currentStyle,
            fontSize: 14,
            fontWeight: "bold",
            marginBottom: 4,
          };
        if (node.tagName.toLowerCase() === "h6")
          currentStyle = {
            ...currentStyle,
            fontSize: 12,
            fontWeight: "bold",
            marginBottom: 3,
          };
        break;
      case "img":
        type = "Image";
        break;
      case "ul":
        type = "View";
        currentStyle = { ...currentStyle, marginBottom: 10 };
        break;
      case "ol":
        type = "View";
        currentStyle = { ...currentStyle, marginBottom: 10 };
        listItemCounter.value = 1; // Reset counter for new ordered list
        break;
      case "li":
        type = "Text";
        currentStyle = { ...currentStyle, marginBottom: 4 };
        break;
      // --- Handle INLINE elements by applying style and processing children directly ---
      case "b":
      case "strong":
        currentStyle = { ...currentStyle, fontWeight: "bold" };
        node.childNodes.forEach((child) => {
          childrenOfCurrentNode.push(
            ...convertNodeToReactPdfObject(child, currentStyle, listItemCounter)
          );
        });
        return childrenOfCurrentNode; // Return flattened children
      case "i":
      case "em":
        currentStyle = { ...currentStyle, fontStyle: "italic" };
        node.childNodes.forEach((child) => {
          childrenOfCurrentNode.push(
            ...convertNodeToReactPdfObject(child, currentStyle, listItemCounter)
          );
        });
        return childrenOfCurrentNode; // Return flattened children
      case "a":
        currentStyle = {
          ...currentStyle,
          color: "blue",
          textDecoration: "underline",
        };
        props.src = node.getAttribute("href");
        node.childNodes.forEach((child) => {
          childrenOfCurrentNode.push(
            ...convertNodeToReactPdfObject(child, currentStyle, listItemCounter)
          );
        });
        results.push({
          type: "Text", // Will be rendered as Link if props.src exists
          props: { ...props, style: currentStyle },
          children:
            childrenOfCurrentNode.length > 0
              ? childrenOfCurrentNode
              : undefined,
        });
        return results;
      case "span":
        node.childNodes.forEach((child) => {
          childrenOfCurrentNode.push(
            ...convertNodeToReactPdfObject(child, currentStyle, listItemCounter)
          );
        });
        return childrenOfCurrentNode; // Return flattened children
      default:
        const displayStyle =
          window.getComputedStyle && window.getComputedStyle(node).display;
        if (displayStyle === "inline" || displayStyle === "inline-block") {
          type = "Text";
        } else {
          type = "View";
        }
        console.warn(
          `Unsupported HTML tag encountered: ${node.tagName}. Converting to <${type}>.`
        );
        break;
    }

    // Copy all other HTML attributes to props (excluding 'style' which is handled)
    for (let i = 0; i < node.attributes.length; i++) {
      const attr = node.attributes[i];
      if (attr.name.toLowerCase() !== "style") {
        const propName = attr.name.replace(/-([a-z])/g, (g) =>
          g[1].toUpperCase()
        );
        props[propName] = attr.value;
      }
    }

    // --- Recursively process child nodes, passing down currentStyle ---
    node.childNodes.forEach((child) => {
      const convertedChildResults = convertNodeToReactPdfObject(
        child,
        currentStyle,
        listItemCounter
      );
      childrenOfCurrentNode.push(...convertedChildResults); // Flatten the array of children
    });

    // --- Construct the final object for the current node ---
    if (type === "Image") {
      results.push({
        type: type,
        props: {
          src: { uri: props.src },
          style: currentStyle,
          ...props,
        },
        children: [],
      });
    } else if (node.tagName.toLowerCase() === "ul") {
      childrenOfCurrentNode.forEach((child) => {
        if (child.type === "Text") {
          results.push({
            type: "View",
            props: {
              style: {
                flexDirection: "row",
                alignItems: "flex-start",
                marginLeft: 10,
              },
            },
            children: [
              {
                type: "Text",
                props: { style: { marginRight: 5, ...child.props.style } },
                children: ["•"],
              },
              child,
            ],
          });
        } else {
          results.push(child);
        }
      });
    } else if (node.tagName.toLowerCase() === "ol") {
      childrenOfCurrentNode.forEach((child) => {
        if (child.type === "Text") {
          results.push({
            type: "View",
            props: {
              style: {
                flexDirection: "row",
                alignItems: "flex-start",
                marginLeft: 10,
              },
            },
            children: [
              {
                type: "Text",
                props: { style: { marginRight: 5, ...child.props.style } },
                children: [`${listItemCounter.value}.`],
              },
              child,
            ],
          });
          listItemCounter.value++;
        } else {
          results.push(child);
        }
      });
    } else {
      results.push({
        type: type,
        props: { ...props, style: currentStyle },
        children:
          childrenOfCurrentNode.length > 0 ? childrenOfCurrentNode : undefined,
      });
    }
  }

  return results;
}

/**
 * Parses an HTML string and transforms it into a JavaScript object structure
 * that can be used to render components with React PDF Renderer.
 *
 * @param {string} htmlString The input HTML string from a rich editor.
 * @returns {Array<object>} An array of JavaScript objects representing the transformed top-level elements.
 */
function replaceHtmlTags(htmlString) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(`<div>${htmlString}</div>`, "text/html");
  const tempContainer = doc.body.firstChild;

  const transformedElements = [];
  const listItemCounter = { value: 1 };

  Array.from(tempContainer.childNodes).forEach((node) => {
    const converted = convertNodeToReactPdfObject(node, {}, listItemCounter);
    transformedElements.push(...converted);
  });

  return transformedElements;
}

export { wrapImagesInContainer, replaceHtmlTags, renderPdfContent };
